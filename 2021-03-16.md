Top level workstreams:

* Storage (page_server)
* Consensus (wal_safekeeper, raft)
* Postgres
* Control Plane
* Devops

Things we decided:

* Rust as an implementation language for Storage + Consensus
* WAL Safekeepers are a separate code module.
  * We can figure out deployment strategy later.
  * Could be colocated with page server or a separate service.

Key Design Questions on Consensus

* How will we detect failure? How do we provide fault tolerance?
  * The main question is: are we going to use k8s or write custom control plane?
  * Observation: It's more common to write a custom solution in the distributed db, scale-out storage space
  * No resolution yet.
* How are we going to handle master node crash?
  * We will use k8s for mechanics (starting a new node)
  * Policy is TBD. See the discussion about custom solutions above
* Do we need a fencing for a crashed node?
  * Yes - raft paper suggests a solution
  * [Related Issue on python implementation](https://github.com/adsharma/raft/issues/10)
* Raft allows overwriting entries in the log. PG WAL doesn't
  * Resolved: we treat raft log as ephemeral and treat only those entries before leader commitIndex as immutable. Technically leader log entries can be overwritten. So we need to wait until one entry to consider it to be really immutable.
* Other issues about the feasibility of Raft
  * Resolved: we will enhance raft to meet our needs.
* What is the relationship between python implementation of raft and the rust implementation?
  * [python implementation](https://github.com/adsharma/raft)
    * Derived from a python implementation with [most github stars](https://github.com/streed/simpleRaft)
    * Written circa 2015 and seems to be unmaintained
    * Many bug fixes and enhancements
    * Very little code review of commits in the last year
  * Arguments against Python
    * We already have a TLA+ spec for verification
    * Translate the spec to working Rust code and be done
    * Rust is what we run in production
  * Arguments for Python
    * The reason why Raft is so much more understandable vs Paxos is because there is a one pager
    * Heidi Howard [wrote](https://twitter.com/heidiann360/status/1254701717150720000/photo/1) one for paxos too, but it has many details that an implementer has to figure out vs Raft
    * We are proposing some changes to Raft
    * Python could be seen as an in-between step between TLA+ and production Rust code.
    * Write tests, debug them easily and once satisfied rewrite in rust
* What is out-of-order raft and why is it needed?
  * Raft TLA+ [spec](https://github.com/ongardie/raft.tla/blob/master/raft.tla#L420) already verifies correctness under out-of-order responses
  * It does so by [nacking](https://github.com/ongardie/raft.tla/blob/master/raft.tla#L329) out or order responses. `logOk` will be false.
  * Leader resends `AppendEntries` in these cases.
  * Another approach to this problem is to have unique IDs associated with `AppendEntriesRPC`
    * This is what the python implementation and Hovercraft do
    * Benefit: No need to resend entries already sent. Less load on the leader.
  * The follower can buffer the out of order entries and apply them in order, or perform optimizations based on an analysis of data dependencies.
  * Discussion: How do we even get to out of order requests with TCP and point-to-point?
  * Discussion: Do we need gossip, Network optimizations for pub/sub?
  * Discussion: How do we verify the correctness and corner cases of such an algorithm?
